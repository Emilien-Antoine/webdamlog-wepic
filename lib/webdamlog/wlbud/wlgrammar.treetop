####License####
 #  File name wlgrammar.treetop
 #  Copyright Â© by INRIA
 #
 #  Contributors : Webdam Team <webdam.inria.fr>
 #       Jules Testard <jules[dot]testard[@]mail[dot]mcgill[dot]ca>
 #       Emilien Antoine <emilien[dot]antoine[@]inria[dot]fr>
 #
 #   WebdamLog - 30 juin 2011
 #
 #   Encoding - UTF-8
####License####

module WLBud

    # This WebdamLogGrammar is strongly linked with the wlvocabulary class that
    # takes the name generated here to define supplementary methods.
    grammar WebdamLogGrammar

      ### Root program ###
      #### Each line is either a comment or it describe either a peer a fact a collection or a rule
      rule root
        comment
        /
        ( (fact / collection / rul / peer_dec) (' '/"\n")* ';' (' '/"\n")* )
      end

      ### Comment ###
      rule comment
        '#' .* <WLComment>
      end

      ### The generic white break line and white space killer
      rule sep
        (' '/"\n")*
      end

      ### The generic filter for words ###
      rule word
        char_in_word+ ('_'* char_in_word+)*
      end
      rule char_in_word
        [a-zA-Z0-9!?:]
      end

      ### Type of entry (peername, fact, collection or rul) ###
      #
        #### peername extended with WLPeerName module
        rule peer_dec
          'peer ' sep peer_name sep '=' sep peer_address <WLPeerName>
        end
        
        #### fact extended with WLFact module
        rule fact
          'fact ' sep relation_name '@' peer_name '(' sep fields sep ')' <WLFact>
        end
        
        #### collection extended with WLCollection module
        rule collection
          'collection ' sep rel_type:relation_type
          sep relation_name '@' peer_name  sep '(' sep col_fields sep ')' <WLCollection>
        end
        rule relation_type
          extensional / intermediary / intensional 
        end
        rule extensional
          ('extensional ' / 'ext ') persistent:(sep persistent)? <WLExtensional>
        end        
        rule intermediary
          ('intermediary ' / 'inter ') persistent:(sep persistent)? <WLIntermediary>
        end
        rule intensional
          'intensional ' <WLIntensional>
          /
          'int ' <WLIntensional>
        end
        rule persistent
           'persistent'
           /
           'per'
        end

        #### rule extended with WLRule module
        rule rul
          'rule ' sep atom sep ':-' sep atoms <WLRule>
        end
        
        rule atoms         
            first_atom:atom list_atoms:( sep ',' sep other_atom:atom )* {
                def get_atoms
                  [first_atom] + list_atoms
                end
                # remove the comma and return an array of atoms
                def list_atoms
                  super.elements.map{ |comma_and_atom| comma_and_atom.other_atom }
                end
             }
        end


      ### for peer ###
        ### define peer ###
        rule peer_name
          word
        end
        rule peer_address
          (ip ':' port)
        end
        ### Rules for type of item ###
        rule ip
          ([0-9]1..3 '.' [0-9]1..3 '.' [0-9]1..3 '.' [0-9]1..3) / 'localhost'
        end
        rule port
          [0-9]1..6
        end
      ### for fact ###
        #### relation name ####
        rule relation_name
          ( '_' / word )
        end
        #### fields ####
        rule fields
           items / [ ]* <WLFields>
        end
        rule col_fields
          keys values / [ ]* <WLFields>
        end
        # value+ for key fields in relations
        rule keys
          ( key sep )+
        end
        #value* for non-key fields in relations
        rule values
          ( value sep )*
        end
        rule key
          item '*' sep ',' / item '*'
        end
        rule value
          item ',' / item
        end
        rule items
            first_item:item list_items:( sep ',' sep other_item:item )* {
                def get_items
                  [first_item] + list_items
                end
                # remove the comma and return an array of items
                def list_items
                  super.elements.map{ |comma_and_item| comma_and_item.other_item }
                end
             }
        end
        rule item
          ( word / ('"' (word / ' ')* '"') / '_' ) <WLItem>
        end
        #rule items
        #  item ','
        #end
            
      ### for rules ###
        #### atom in rules ####
        rule atom
          rrelation '@' rpeer sep '(' sep rfields sep ')' <WLAtom>
        end
          ###### relation name in atom #####
          rule rrelation
            (relation_name / variable) {
            def variable
              if self.is_a?(WLBud::WLVar) then return self else return nil end
            end
            }
          end
          ###### peer name in atom #####
          rule rpeer
            peer_name / variable {
            def variable
              if self.is_a?(WLBud::WLVar) then return self else return nil end
            end
            }
          end
          ###### attributes name in atom #####
          rule rfields
            first_rtoken:rtoken list_rtokens:( sep ',' sep other_rtoken:rtoken )* <WLRfields>
          end
            ####### attributes name in atom ######
            #rule rtokens
            # (rtoken ',')*
            #end
            rule rtoken
              (variable / item) <WLRToken>
            end
            rule variable
              '$' char_in_word+ <WLVar>
            end

   end # grammar WebdamLogGrammar
end # module WLBud