# Autogenerated from a Treetop grammar. Edits may be lost.


####License####
 #  File name wlgrammar.treetop
 #  Copyright Â© by INRIA
 #
 #  Contributors : Webdam Team <webdam.inria.fr>
 #       Jules Testard <jules[dot]testard[@]mail[dot]mcgill[dot]ca>
 #       Emilien Antoine <emilien[dot]antoine[@]inria[dot]fr>
 #
 #   WebdamLog - 30 juin 2011
 #
 #   Encoding - UTF-8
####License####

module WLBud

    # This WebdamLogGrammar is strongly linked with the wlvocabulary class that
    # takes the name generated here to define supplementary methods.
    module WebdamLogGrammar
      include Treetop::Runtime

      def root
        @root ||= :root
      end

      module Root0
      end

      def _nt_root
        start_index = index
        if node_cache[:root].has_key?(index)
          cached = node_cache[:root][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_comment
        if r1
          r0 = r1
        else
          i2, s2 = index, []
          i3 = index
          r4 = _nt_fact
          if r4
            r3 = r4
          else
            r5 = _nt_collection
            if r5
              r3 = r5
            else
              r6 = _nt_rul
              if r6
                r3 = r6
              else
                r7 = _nt_peer_dec
                if r7
                  r3 = r7
                else
                  @index = i3
                  r3 = nil
                end
              end
            end
          end
          s2 << r3
          if r3
            s8, i8 = [], index
            loop do
              i9 = index
              if has_terminal?(' ', false, index)
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(' ')
                r10 = nil
              end
              if r10
                r9 = r10
              else
                if has_terminal?("\n", false, index)
                  r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure("\n")
                  r11 = nil
                end
                if r11
                  r9 = r11
                else
                  @index = i9
                  r9 = nil
                end
              end
              if r9
                s8 << r9
              else
                break
              end
            end
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            s2 << r8
            if r8
              if has_terminal?(';', false, index)
                r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(';')
                r12 = nil
              end
              s2 << r12
              if r12
                s13, i13 = [], index
                loop do
                  i14 = index
                  if has_terminal?(' ', false, index)
                    r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(' ')
                    r15 = nil
                  end
                  if r15
                    r14 = r15
                  else
                    if has_terminal?("\n", false, index)
                      r16 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure("\n")
                      r16 = nil
                    end
                    if r16
                      r14 = r16
                    else
                      @index = i14
                      r14 = nil
                    end
                  end
                  if r14
                    s13 << r14
                  else
                    break
                  end
                end
                r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                s2 << r13
              end
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(Root0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:root][start_index] = r0

        r0
      end

      module Comment0
      end

      def _nt_comment
        start_index = index
        if node_cache[:comment].has_key?(index)
          cached = node_cache[:comment][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('#', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('#')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if index < input_length
              r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("any character")
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(WLComment,input, i0...index, s0)
          r0.extend(Comment0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment][start_index] = r0

        r0
      end

      def _nt_sep
        start_index = index
        if node_cache[:sep].has_key?(index)
          cached = node_cache[:sep][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(' ', false, index)
            r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(' ')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:sep][start_index] = r0

        r0
      end

      module Word0
      end

      module Word1
      end

      def _nt_word
        start_index = index
        if node_cache[:word].has_key?(index)
          cached = node_cache[:word][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          if has_terminal?('\G[a-zA-Z0-9!?]', true, index)
            r2 = true
            @index += 1
          else
            r2 = nil
          end
          if r2
            s1 << r2
          else
            break
          end
        end
        if s1.empty?
          @index = i1
          r1 = nil
        else
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        end
        s0 << r1
        if r1
          s3, i3 = [], index
          loop do
            i4, s4 = index, []
            s5, i5 = [], index
            loop do
              if has_terminal?('_', false, index)
                r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('_')
                r6 = nil
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s4 << r5
            if r5
              s7, i7 = [], index
              loop do
                if has_terminal?('\G[a-zA-Z0-9!?]', true, index)
                  r8 = true
                  @index += 1
                else
                  r8 = nil
                end
                if r8
                  s7 << r8
                else
                  break
                end
              end
              if s7.empty?
                @index = i7
                r7 = nil
              else
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              end
              s4 << r7
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(Word0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Word1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:word][start_index] = r0

        r0
      end

      module PeerDec0
        def sep1
          elements[1]
        end

        def peer_name
          elements[2]
        end

        def sep2
          elements[3]
        end

        def sep3
          elements[5]
        end

        def peer_address
          elements[6]
        end
      end

      def _nt_peer_dec
        start_index = index
        if node_cache[:peer_dec].has_key?(index)
          cached = node_cache[:peer_dec][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('peer ', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('peer ')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_sep
          s0 << r2
          if r2
            r3 = _nt_peer_name
            s0 << r3
            if r3
              r4 = _nt_sep
              s0 << r4
              if r4
                if has_terminal?('=', false, index)
                  r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure('=')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_sep
                  s0 << r6
                  if r6
                    r7 = _nt_peer_address
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(WLPeerName,input, i0...index, s0)
          r0.extend(PeerDec0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:peer_dec][start_index] = r0

        r0
      end

      module Fact0
        def sep1
          elements[1]
        end

        def relation_name
          elements[2]
        end

        def peer_name
          elements[4]
        end

        def sep2
          elements[6]
        end

        def fields
          elements[7]
        end

        def sep3
          elements[8]
        end

      end

      def _nt_fact
        start_index = index
        if node_cache[:fact].has_key?(index)
          cached = node_cache[:fact][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('fact ', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('fact ')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_sep
          s0 << r2
          if r2
            r3 = _nt_relation_name
            s0 << r3
            if r3
              if has_terminal?('@', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('@')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_peer_name
                s0 << r5
                if r5
                  if has_terminal?('(', false, index)
                    r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('(')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_sep
                    s0 << r7
                    if r7
                      r8 = _nt_fields
                      s0 << r8
                      if r8
                        r9 = _nt_sep
                        s0 << r9
                        if r9
                          if has_terminal?(')', false, index)
                            r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                            @index += 1
                          else
                            terminal_parse_failure(')')
                            r10 = nil
                          end
                          s0 << r10
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(WLFact,input, i0...index, s0)
          r0.extend(Fact0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:fact][start_index] = r0

        r0
      end

      module Collection0
        def sep1
          elements[1]
        end

        def rel_type
          elements[2]
        end

        def sep2
          elements[3]
        end

        def relation_name
          elements[4]
        end

        def peer_name
          elements[6]
        end

        def sep3
          elements[7]
        end

        def sep4
          elements[9]
        end

        def col_fields
          elements[10]
        end

        def sep5
          elements[11]
        end

      end

      def _nt_collection
        start_index = index
        if node_cache[:collection].has_key?(index)
          cached = node_cache[:collection][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('collection ', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 11))
          @index += 11
        else
          terminal_parse_failure('collection ')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_sep
          s0 << r2
          if r2
            r3 = _nt_relation_type
            s0 << r3
            if r3
              r4 = _nt_sep
              s0 << r4
              if r4
                r5 = _nt_relation_name
                s0 << r5
                if r5
                  if has_terminal?('@', false, index)
                    r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('@')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_peer_name
                    s0 << r7
                    if r7
                      r8 = _nt_sep
                      s0 << r8
                      if r8
                        if has_terminal?('(', false, index)
                          r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                          @index += 1
                        else
                          terminal_parse_failure('(')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_sep
                          s0 << r10
                          if r10
                            r11 = _nt_col_fields
                            s0 << r11
                            if r11
                              r12 = _nt_sep
                              s0 << r12
                              if r12
                                if has_terminal?(')', false, index)
                                  r13 = instantiate_node(SyntaxNode,input, index...(index + 1))
                                  @index += 1
                                else
                                  terminal_parse_failure(')')
                                  r13 = nil
                                end
                                s0 << r13
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(WLCollection,input, i0...index, s0)
          r0.extend(Collection0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:collection][start_index] = r0

        r0
      end

      def _nt_relation_type
        start_index = index
        if node_cache[:relation_type].has_key?(index)
          cached = node_cache[:relation_type][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_extensional
        if r1
          r0 = r1
        else
          r2 = _nt_intermediary
          if r2
            r0 = r2
          else
            r3 = _nt_intensional
            if r3
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:relation_type][start_index] = r0

        r0
      end

      module Extensional0
        def sep
          elements[0]
        end

        def persistent
          elements[1]
        end
      end

      module Extensional1
        def persistent
          elements[1]
        end
      end

      def _nt_extensional
        start_index = index
        if node_cache[:extensional].has_key?(index)
          cached = node_cache[:extensional][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if has_terminal?('extensional ', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 12))
          @index += 12
        else
          terminal_parse_failure('extensional ')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          if has_terminal?('ext ', false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
            @index += 4
          else
            terminal_parse_failure('ext ')
            r3 = nil
          end
          if r3
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i5, s5 = index, []
          r6 = _nt_sep
          s5 << r6
          if r6
            r7 = _nt_persistent
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Extensional0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(WLExtensional,input, i0...index, s0)
          r0.extend(Extensional1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:extensional][start_index] = r0

        r0
      end

      module Intermediary0
        def sep
          elements[0]
        end

        def persistent
          elements[1]
        end
      end

      module Intermediary1
        def persistent
          elements[1]
        end
      end

      def _nt_intermediary
        start_index = index
        if node_cache[:intermediary].has_key?(index)
          cached = node_cache[:intermediary][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if has_terminal?('intermediary ', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 13))
          @index += 13
        else
          terminal_parse_failure('intermediary ')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          if has_terminal?('inter ', false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 6))
            @index += 6
          else
            terminal_parse_failure('inter ')
            r3 = nil
          end
          if r3
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i5, s5 = index, []
          r6 = _nt_sep
          s5 << r6
          if r6
            r7 = _nt_persistent
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Intermediary0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(WLIntermediary,input, i0...index, s0)
          r0.extend(Intermediary1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:intermediary][start_index] = r0

        r0
      end

      def _nt_intensional
        start_index = index
        if node_cache[:intensional].has_key?(index)
          cached = node_cache[:intensional][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('intensional ', false, index)
          r1 = instantiate_node(WLIntensional,input, index...(index + 12))
          @index += 12
        else
          terminal_parse_failure('intensional ')
          r1 = nil
        end
        if r1
          r0 = r1
        else
          if has_terminal?('int ', false, index)
            r2 = instantiate_node(WLIntensional,input, index...(index + 4))
            @index += 4
          else
            terminal_parse_failure('int ')
            r2 = nil
          end
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:intensional][start_index] = r0

        r0
      end

      def _nt_persistent
        start_index = index
        if node_cache[:persistent].has_key?(index)
          cached = node_cache[:persistent][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('persistent', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 10))
          @index += 10
        else
          terminal_parse_failure('persistent')
          r1 = nil
        end
        if r1
          r0 = r1
        else
          if has_terminal?('per', false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
            @index += 3
          else
            terminal_parse_failure('per')
            r2 = nil
          end
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:persistent][start_index] = r0

        r0
      end

      module Rul0
        def sep1
          elements[1]
        end

        def atom
          elements[2]
        end

        def sep2
          elements[3]
        end

        def sep3
          elements[5]
        end

        def atoms
          elements[6]
        end
      end

      def _nt_rul
        start_index = index
        if node_cache[:rul].has_key?(index)
          cached = node_cache[:rul][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('rule ', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure('rule ')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_sep
          s0 << r2
          if r2
            r3 = _nt_atom
            s0 << r3
            if r3
              r4 = _nt_sep
              s0 << r4
              if r4
                if has_terminal?(':-', false, index)
                  r5 = instantiate_node(SyntaxNode,input, index...(index + 2))
                  @index += 2
                else
                  terminal_parse_failure(':-')
                  r5 = nil
                end
                s0 << r5
                if r5
                  r6 = _nt_sep
                  s0 << r6
                  if r6
                    r7 = _nt_atoms
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(WLRule,input, i0...index, s0)
          r0.extend(Rul0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:rul][start_index] = r0

        r0
      end

      module Atoms0
        def atom
          elements[0]
        end

      end

      def _nt_atoms
        start_index = index
        if node_cache[:atoms].has_key?(index)
          cached = node_cache[:atoms][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1 = index
          i2, s2 = index, []
          r3 = _nt_atom
          s2 << r3
          if r3
            if has_terminal?(',', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s2 << r4
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(Atoms0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r1 = r2
          else
            r5 = _nt_atom
            if r5
              r1 = r5
            else
              @index = i1
              r1 = nil
            end
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:atoms][start_index] = r0

        r0
      end

      def _nt_peer_name
        start_index = index
        if node_cache[:peer_name].has_key?(index)
          cached = node_cache[:peer_name][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_word

        node_cache[:peer_name][start_index] = r0

        r0
      end

      module PeerAddress0
        def ip
          elements[0]
        end

        def port
          elements[2]
        end
      end

      def _nt_peer_address
        start_index = index
        if node_cache[:peer_address].has_key?(index)
          cached = node_cache[:peer_address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_ip
        s0 << r1
        if r1
          if has_terminal?(':', false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(':')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_port
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PeerAddress0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:peer_address][start_index] = r0

        r0
      end

      module Ip0
      end

      def _nt_ip
        start_index = index
        if node_cache[:ip].has_key?(index)
          cached = node_cache[:ip][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r3 = true
            @index += 1
          else
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
          if s2.size == 3
            break
          end
        end
        if s2.size < 1
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if has_terminal?('.', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('.')
            r4 = nil
          end
          s1 << r4
          if r4
            s5, i5 = [], index
            loop do
              if has_terminal?('\G[0-9]', true, index)
                r6 = true
                @index += 1
              else
                r6 = nil
              end
              if r6
                s5 << r6
              else
                break
              end
              if s5.size == 3
                break
              end
            end
            if s5.size < 1
              @index = i5
              r5 = nil
            else
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            end
            s1 << r5
            if r5
              if has_terminal?('.', false, index)
                r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('.')
                r7 = nil
              end
              s1 << r7
              if r7
                s8, i8 = [], index
                loop do
                  if has_terminal?('\G[0-9]', true, index)
                    r9 = true
                    @index += 1
                  else
                    r9 = nil
                  end
                  if r9
                    s8 << r9
                  else
                    break
                  end
                  if s8.size == 3
                    break
                  end
                end
                if s8.size < 1
                  @index = i8
                  r8 = nil
                else
                  r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                end
                s1 << r8
                if r8
                  if has_terminal?('.', false, index)
                    r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('.')
                    r10 = nil
                  end
                  s1 << r10
                  if r10
                    s11, i11 = [], index
                    loop do
                      if has_terminal?('\G[0-9]', true, index)
                        r12 = true
                        @index += 1
                      else
                        r12 = nil
                      end
                      if r12
                        s11 << r12
                      else
                        break
                      end
                      if s11.size == 3
                        break
                      end
                    end
                    if s11.size < 1
                      @index = i11
                      r11 = nil
                    else
                      r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                    end
                    s1 << r11
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Ip0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
        else
          if has_terminal?('localhost', false, index)
            r13 = instantiate_node(SyntaxNode,input, index...(index + 9))
            @index += 9
          else
            terminal_parse_failure('localhost')
            r13 = nil
          end
          if r13
            r0 = r13
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:ip][start_index] = r0

        r0
      end

      def _nt_port
        start_index = index
        if node_cache[:port].has_key?(index)
          cached = node_cache[:port][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
          if s0.size == 6
            break
          end
        end
        if s0.size < 1
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:port][start_index] = r0

        r0
      end

      def _nt_relation_name
        start_index = index
        if node_cache[:relation_name].has_key?(index)
          cached = node_cache[:relation_name][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('_', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('_')
          r1 = nil
        end
        if r1
          r0 = r1
        else
          r2 = _nt_word
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:relation_name][start_index] = r0

        r0
      end

      module Fields0
        def item
          elements[1]
        end
      end

      def _nt_fields
        start_index = index
        if node_cache[:fields].has_key?(index)
          cached = node_cache[:fields][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          r3 = _nt_items
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s1 << r2
        if r2
          r4 = _nt_item
          s1 << r4
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Fields0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
        else
          s5, i5 = [], index
          loop do
            if has_terminal?('\G[ ]', true, index)
              r6 = true
              @index += 1
            else
              r6 = nil
            end
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(WLFields,input, i5...index, s5)
          if r5
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:fields][start_index] = r0

        r0
      end

      module ColFields0
        def keys
          elements[0]
        end

        def values
          elements[1]
        end
      end

      def _nt_col_fields
        start_index = index
        if node_cache[:col_fields].has_key?(index)
          cached = node_cache[:col_fields][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_keys
        s1 << r2
        if r2
          r3 = _nt_values
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ColFields0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
        else
          s4, i4 = [], index
          loop do
            if has_terminal?('\G[ ]', true, index)
              r5 = true
              @index += 1
            else
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(WLFields,input, i4...index, s4)
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:col_fields][start_index] = r0

        r0
      end

      def _nt_keys
        start_index = index
        if node_cache[:keys].has_key?(index)
          cached = node_cache[:keys][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_key
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:keys][start_index] = r0

        r0
      end

      def _nt_values
        start_index = index
        if node_cache[:values].has_key?(index)
          cached = node_cache[:values][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_value
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:values][start_index] = r0

        r0
      end

      module Key0
        def item
          elements[0]
        end

      end

      module Key1
        def item
          elements[0]
        end

      end

      def _nt_key
        start_index = index
        if node_cache[:key].has_key?(index)
          cached = node_cache[:key][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_item
        s1 << r2
        if r2
          if has_terminal?('*', false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('*')
            r3 = nil
          end
          s1 << r3
          if r3
            if has_terminal?(',', false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(',')
              r4 = nil
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Key0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
        else
          i5, s5 = index, []
          r6 = _nt_item
          s5 << r6
          if r6
            if has_terminal?('*', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('*')
              r7 = nil
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Key1)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:key][start_index] = r0

        r0
      end

      module Value0
        def item
          elements[0]
        end

      end

      def _nt_value
        start_index = index
        if node_cache[:value].has_key?(index)
          cached = node_cache[:value][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_item
        s1 << r2
        if r2
          if has_terminal?(',', false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(',')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Value0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r0 = r1
        else
          r4 = _nt_item
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:value][start_index] = r0

        r0
      end

      module Item0
        def word
          elements[0]
        end

      end

      module Item1
      end

      def _nt_item
        start_index = index
        if node_cache[:item].has_key?(index)
          cached = node_cache[:item][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_word
        if r1
          r0 = r1
          r0.extend(WLItem)
        else
          i2, s2 = index, []
          if has_terminal?('"', false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('"')
            r3 = nil
          end
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5, s5 = index, []
              r6 = _nt_word
              s5 << r6
              if r6
                s7, i7 = [], index
                loop do
                  if has_terminal?(' ', false, index)
                    r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(' ')
                    r8 = nil
                  end
                  if r8
                    s7 << r8
                  else
                    break
                  end
                end
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                s5 << r7
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(Item0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s2 << r4
            if r4
              if has_terminal?('"', false, index)
                r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('"')
                r9 = nil
              end
              s2 << r9
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(Item1)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r0 = r2
            r0.extend(WLItem)
          else
            if has_terminal?('_', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('_')
              r10 = nil
            end
            if r10
              r0 = r10
              r0.extend(WLItem)
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:item][start_index] = r0

        r0
      end

      module Items0
        def item
          elements[0]
        end

      end

      def _nt_items
        start_index = index
        if node_cache[:items].has_key?(index)
          cached = node_cache[:items][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_item
        s0 << r1
        if r1
          if has_terminal?(',', false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(',')
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Items0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:items][start_index] = r0

        r0
      end

      module Atom0
        def rrelation
          elements[0]
        end

        def rpeer
          elements[2]
        end

        def rfields
          elements[4]
        end

      end

      def _nt_atom
        start_index = index
        if node_cache[:atom].has_key?(index)
          cached = node_cache[:atom][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_rrelation
        s0 << r1
        if r1
          if has_terminal?('@', false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('@')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_rpeer
            s0 << r3
            if r3
              if has_terminal?('(', false, index)
                r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('(')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_rfields
                s0 << r5
                if r5
                  if has_terminal?(')', false, index)
                    r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure(')')
                    r6 = nil
                  end
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(WLAtom,input, i0...index, s0)
          r0.extend(Atom0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:atom][start_index] = r0

        r0
      end

      module Rrelation0
        def variable
          if self.is_a?(WLBud::WLVar) then return self else return nil end
        end
      end

      def _nt_rrelation
        start_index = index
        if node_cache[:rrelation].has_key?(index)
          cached = node_cache[:rrelation][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_relation_name
        if r1
          r0 = r1
          r0.extend(Rrelation0)
        else
          r2 = _nt_variable
          if r2
            r0 = r2
            r0.extend(Rrelation0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:rrelation][start_index] = r0

        r0
      end

      module Rpeer0
        def variable
          if self.is_a?(WLBud::WLVar) then return self else return nil end
        end
      end

      def _nt_rpeer
        start_index = index
        if node_cache[:rpeer].has_key?(index)
          cached = node_cache[:rpeer][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_peer_name
        if r1
          r0 = r1
        else
          r2 = _nt_variable
          r2.extend(Rpeer0)
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:rpeer][start_index] = r0

        r0
      end

      module Rfields0
        def rtokens
          elements[0]
        end

        def rtoken
          elements[1]
        end
      end

      def _nt_rfields
        start_index = index
        if node_cache[:rfields].has_key?(index)
          cached = node_cache[:rfields][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_rtokens
        s0 << r1
        if r1
          r2 = _nt_rtoken
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(WLRfields,input, i0...index, s0)
          r0.extend(Rfields0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:rfields][start_index] = r0

        r0
      end

      module Rtokens0
        def rtoken
          elements[0]
        end

      end

      def _nt_rtokens
        start_index = index
        if node_cache[:rtokens].has_key?(index)
          cached = node_cache[:rtokens][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          r2 = _nt_rtoken
          s1 << r2
          if r2
            if has_terminal?(',', false, index)
              r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(',')
              r3 = nil
            end
            s1 << r3
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Rtokens0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:rtokens][start_index] = r0

        r0
      end

      def _nt_rtoken
        start_index = index
        if node_cache[:rtoken].has_key?(index)
          cached = node_cache[:rtoken][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_variable
        if r1
          r0 = r1
        else
          r2 = _nt_item
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:rtoken][start_index] = r0

        r0
      end

      module Variable0
      end

      def _nt_variable
        start_index = index
        if node_cache[:variable].has_key?(index)
          cached = node_cache[:variable][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?('$', false, index)
          r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('$')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?('\G[a-zA-Z0-9]', true, index)
            r2 = true
            @index += 1
          else
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(WLVar,input, i0...index, s0)
          r0.extend(Variable0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variable][start_index] = r0

        r0
      end

    end

    class WebdamLogGrammarParser < Treetop::Runtime::CompiledParser
      include WebdamLogGrammar
    end

end